// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AppInitParameters struct {

	// Add annotations as described here.
	// Works only on cloud foundry with api >= v3.63.
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// The buildpack used to stage the application. There are multiple options to choose from:
	Buildpack *string `json:"buildpack,omitempty" tf:"buildpack,omitempty"`

	// Multiple buildpacks used to stage the application. When both buildpack and buildpacks are set, buildpacks wins. There are multiple options to choose from:
	Buildpacks []*string `json:"buildpacks,omitempty" tf:"buildpacks,omitempty"`

	// A custom start command for the application. This overrides the start command provided by the buildpack.
	Command *string `json:"command,omitempty" tf:"command,omitempty"`

	// The disk space to be allocated for each application instance in megabytes. If not provided, default disk quota is retrieved from Cloud Foundry and assigned.
	DiskQuota *float64 `json:"diskQuota,omitempty" tf:"disk_quota,omitempty"`

	// The URL to the docker image with tag e.g registry.example.com:5000/user/repository/tag or docker image name from the public repo e.g. redis:4.0
	DockerImage *string `json:"dockerImage,omitempty" tf:"docker_image,omitempty"`

	// Whether to enable or disable SSH access to the container. Default is true unless disabled globally.
	EnableSSH *bool `json:"enableSsh,omitempty" tf:"enable_ssh,omitempty"`

	// The endpoint for the http health check type. The default is '/'.
	HealthCheckHTTPEndpoint *string `json:"healthCheckHttpEndpoint,omitempty" tf:"health_check_http_endpoint,omitempty"`

	// The timeout in seconds for individual health check requests for "http" and "port" health checks.
	HealthCheckInvocationTimeout *float64 `json:"healthCheckInvocationTimeout,omitempty" tf:"health_check_invocation_timeout,omitempty"`

	// The timeout in seconds for the health check.
	HealthCheckTimeout *float64 `json:"healthCheckTimeout,omitempty" tf:"health_check_timeout,omitempty"`

	// The health check type which can be one of "port", "process", "http". Default is "port".
	HealthCheckType *string `json:"healthCheckType,omitempty" tf:"health_check_type,omitempty"`

	// The number of app instances that you want to start. Defaults to 1.
	Instances *float64 `json:"instances,omitempty" tf:"instances,omitempty"`

	// Add labels as described here.
	// Works only on cloud foundry with api >= v3.63.
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The memory limit for each application instance in megabytes. If not provided, value is computed and retreived from Cloud Foundry.
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// An uri or path to target a zip file. this can be in the form of unix path (/my/path.zip) or url path (http://zip.com/my.zip)
	// Path to an app zip in the form of unix path or http url
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// The routes to map to the application to control its ingress traffic.
	Routes []RoutesInitParameters `json:"routes,omitempty" tf:"routes,omitempty"`

	// Service instances to bind to the application.
	ServiceBinding []ServiceBindingInitParameters `json:"serviceBinding,omitempty" tf:"service_binding,omitempty"`

	// Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the path specified. The usual way to set this is ${base64sha256(file("file.zip"))},
	// where "file.zip" is the local filename of the lambda function source archive.
	SourceCodeHash *string `json:"sourceCodeHash,omitempty" tf:"source_code_hash,omitempty"`

	// The GUID of the associated Cloud Foundry space.
	Space *string `json:"space,omitempty" tf:"space,omitempty"`

	// The name of the stack the application will be deployed to. Use the cloudfoundry_stack data resource to lookup the available stack names to override Cloud Foundry default.
	Stack *string `json:"stack,omitempty" tf:"stack,omitempty"`

	// Defines the desired application state. Set to true to have the application remain in a stopped state. Default is false, i.e. application will be started.
	Stopped *bool `json:"stopped,omitempty" tf:"stopped,omitempty"`

	// Strategy to use for creating/updating application. Defaults to none
	// Supported options:
	// Deployment strategy, default to none but accept blue-green strategy
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// Max wait time for app instance startup, in seconds. Defaults to 60 seconds.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type AppObservation struct {

	// Add annotations as described here.
	// Works only on cloud foundry with api >= v3.63.
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// The buildpack used to stage the application. There are multiple options to choose from:
	Buildpack *string `json:"buildpack,omitempty" tf:"buildpack,omitempty"`

	// Multiple buildpacks used to stage the application. When both buildpack and buildpacks are set, buildpacks wins. There are multiple options to choose from:
	Buildpacks []*string `json:"buildpacks,omitempty" tf:"buildpacks,omitempty"`

	// A custom start command for the application. This overrides the start command provided by the buildpack.
	Command *string `json:"command,omitempty" tf:"command,omitempty"`

	// The disk space to be allocated for each application instance in megabytes. If not provided, default disk quota is retrieved from Cloud Foundry and assigned.
	DiskQuota *float64 `json:"diskQuota,omitempty" tf:"disk_quota,omitempty"`

	// The URL to the docker image with tag e.g registry.example.com:5000/user/repository/tag or docker image name from the public repo e.g. redis:4.0
	DockerImage *string `json:"dockerImage,omitempty" tf:"docker_image,omitempty"`

	// Whether to enable or disable SSH access to the container. Default is true unless disabled globally.
	EnableSSH *bool `json:"enableSsh,omitempty" tf:"enable_ssh,omitempty"`

	// The endpoint for the http health check type. The default is '/'.
	HealthCheckHTTPEndpoint *string `json:"healthCheckHttpEndpoint,omitempty" tf:"health_check_http_endpoint,omitempty"`

	// The timeout in seconds for individual health check requests for "http" and "port" health checks.
	HealthCheckInvocationTimeout *float64 `json:"healthCheckInvocationTimeout,omitempty" tf:"health_check_invocation_timeout,omitempty"`

	// The timeout in seconds for the health check.
	HealthCheckTimeout *float64 `json:"healthCheckTimeout,omitempty" tf:"health_check_timeout,omitempty"`

	// The health check type which can be one of "port", "process", "http". Default is "port".
	HealthCheckType *string `json:"healthCheckType,omitempty" tf:"health_check_type,omitempty"`

	// The GUID of the application
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The GUID of the application updated by resource when strategy is blue-green.
	IDBg *string `json:"idBg,omitempty" tf:"id_bg,omitempty"`

	// The number of app instances that you want to start. Defaults to 1.
	Instances *float64 `json:"instances,omitempty" tf:"instances,omitempty"`

	// Add labels as described here.
	// Works only on cloud foundry with api >= v3.63.
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The memory limit for each application instance in megabytes. If not provided, value is computed and retreived from Cloud Foundry.
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// An uri or path to target a zip file. this can be in the form of unix path (/my/path.zip) or url path (http://zip.com/my.zip)
	// Path to an app zip in the form of unix path or http url
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// The routes to map to the application to control its ingress traffic.
	Routes []RoutesObservation `json:"routes,omitempty" tf:"routes,omitempty"`

	// Service instances to bind to the application.
	ServiceBinding []ServiceBindingObservation `json:"serviceBinding,omitempty" tf:"service_binding,omitempty"`

	// Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the path specified. The usual way to set this is ${base64sha256(file("file.zip"))},
	// where "file.zip" is the local filename of the lambda function source archive.
	SourceCodeHash *string `json:"sourceCodeHash,omitempty" tf:"source_code_hash,omitempty"`

	// The GUID of the associated Cloud Foundry space.
	Space *string `json:"space,omitempty" tf:"space,omitempty"`

	// The name of the stack the application will be deployed to. Use the cloudfoundry_stack data resource to lookup the available stack names to override Cloud Foundry default.
	Stack *string `json:"stack,omitempty" tf:"stack,omitempty"`

	// Defines the desired application state. Set to true to have the application remain in a stopped state. Default is false, i.e. application will be started.
	Stopped *bool `json:"stopped,omitempty" tf:"stopped,omitempty"`

	// Strategy to use for creating/updating application. Defaults to none
	// Supported options:
	// Deployment strategy, default to none but accept blue-green strategy
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// Max wait time for app instance startup, in seconds. Defaults to 60 seconds.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type AppParameters struct {

	// Add annotations as described here.
	// Works only on cloud foundry with api >= v3.63.
	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// The buildpack used to stage the application. There are multiple options to choose from:
	// +kubebuilder:validation:Optional
	Buildpack *string `json:"buildpack,omitempty" tf:"buildpack,omitempty"`

	// Multiple buildpacks used to stage the application. When both buildpack and buildpacks are set, buildpacks wins. There are multiple options to choose from:
	// +kubebuilder:validation:Optional
	Buildpacks []*string `json:"buildpacks,omitempty" tf:"buildpacks,omitempty"`

	// A custom start command for the application. This overrides the start command provided by the buildpack.
	// +kubebuilder:validation:Optional
	Command *string `json:"command,omitempty" tf:"command,omitempty"`

	// The disk space to be allocated for each application instance in megabytes. If not provided, default disk quota is retrieved from Cloud Foundry and assigned.
	// +kubebuilder:validation:Optional
	DiskQuota *float64 `json:"diskQuota,omitempty" tf:"disk_quota,omitempty"`

	// Defines login credentials for private docker repositories
	// +kubebuilder:validation:Optional
	DockerCredentialsSecretRef *v1.SecretReference `json:"dockerCredentialsSecretRef,omitempty" tf:"-"`

	// The URL to the docker image with tag e.g registry.example.com:5000/user/repository/tag or docker image name from the public repo e.g. redis:4.0
	// +kubebuilder:validation:Optional
	DockerImage *string `json:"dockerImage,omitempty" tf:"docker_image,omitempty"`

	// Whether to enable or disable SSH access to the container. Default is true unless disabled globally.
	// +kubebuilder:validation:Optional
	EnableSSH *bool `json:"enableSsh,omitempty" tf:"enable_ssh,omitempty"`

	// Key/value pairs of custom environment variables to set in your app. Does not include any system or service variables.
	// +kubebuilder:validation:Optional
	EnvironmentSecretRef *v1.SecretReference `json:"environmentSecretRef,omitempty" tf:"-"`

	// The endpoint for the http health check type. The default is '/'.
	// +kubebuilder:validation:Optional
	HealthCheckHTTPEndpoint *string `json:"healthCheckHttpEndpoint,omitempty" tf:"health_check_http_endpoint,omitempty"`

	// The timeout in seconds for individual health check requests for "http" and "port" health checks.
	// +kubebuilder:validation:Optional
	HealthCheckInvocationTimeout *float64 `json:"healthCheckInvocationTimeout,omitempty" tf:"health_check_invocation_timeout,omitempty"`

	// The timeout in seconds for the health check.
	// +kubebuilder:validation:Optional
	HealthCheckTimeout *float64 `json:"healthCheckTimeout,omitempty" tf:"health_check_timeout,omitempty"`

	// The health check type which can be one of "port", "process", "http". Default is "port".
	// +kubebuilder:validation:Optional
	HealthCheckType *string `json:"healthCheckType,omitempty" tf:"health_check_type,omitempty"`

	// The number of app instances that you want to start. Defaults to 1.
	// +kubebuilder:validation:Optional
	Instances *float64 `json:"instances,omitempty" tf:"instances,omitempty"`

	// Add labels as described here.
	// Works only on cloud foundry with api >= v3.63.
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// The memory limit for each application instance in megabytes. If not provided, value is computed and retreived from Cloud Foundry.
	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// An uri or path to target a zip file. this can be in the form of unix path (/my/path.zip) or url path (http://zip.com/my.zip)
	// Path to an app zip in the form of unix path or http url
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// The routes to map to the application to control its ingress traffic.
	// +kubebuilder:validation:Optional
	Routes []RoutesParameters `json:"routes,omitempty" tf:"routes,omitempty"`

	// Service instances to bind to the application.
	// +kubebuilder:validation:Optional
	ServiceBinding []ServiceBindingParameters `json:"serviceBinding,omitempty" tf:"service_binding,omitempty"`

	// Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the path specified. The usual way to set this is ${base64sha256(file("file.zip"))},
	// where "file.zip" is the local filename of the lambda function source archive.
	// +kubebuilder:validation:Optional
	SourceCodeHash *string `json:"sourceCodeHash,omitempty" tf:"source_code_hash,omitempty"`

	// The GUID of the associated Cloud Foundry space.
	// +kubebuilder:validation:Optional
	Space *string `json:"space,omitempty" tf:"space,omitempty"`

	// The name of the stack the application will be deployed to. Use the cloudfoundry_stack data resource to lookup the available stack names to override Cloud Foundry default.
	// +kubebuilder:validation:Optional
	Stack *string `json:"stack,omitempty" tf:"stack,omitempty"`

	// Defines the desired application state. Set to true to have the application remain in a stopped state. Default is false, i.e. application will be started.
	// +kubebuilder:validation:Optional
	Stopped *bool `json:"stopped,omitempty" tf:"stopped,omitempty"`

	// Strategy to use for creating/updating application. Defaults to none
	// Supported options:
	// Deployment strategy, default to none but accept blue-green strategy
	// +kubebuilder:validation:Optional
	Strategy *string `json:"strategy,omitempty" tf:"strategy,omitempty"`

	// Max wait time for app instance startup, in seconds. Defaults to 60 seconds.
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type RoutesInitParameters struct {

	// (Number) The port of the application to map the tcp route to.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// The route id. Route can be defined using the cloudfoundry_route resource
	Route *string `json:"route,omitempty" tf:"route,omitempty"`
}

type RoutesObservation struct {

	// (Number) The port of the application to map the tcp route to.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// The route id. Route can be defined using the cloudfoundry_route resource
	Route *string `json:"route,omitempty" tf:"route,omitempty"`
}

type RoutesParameters struct {

	// (Number) The port of the application to map the tcp route to.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// The route id. Route can be defined using the cloudfoundry_route resource
	// +kubebuilder:validation:Optional
	Route *string `json:"route" tf:"route,omitempty"`
}

type ServiceBindingInitParameters struct {

	// The service instance GUID.
	ServiceInstance *string `json:"serviceInstance,omitempty" tf:"service_instance,omitempty"`
}

type ServiceBindingObservation struct {

	// The service instance GUID.
	ServiceInstance *string `json:"serviceInstance,omitempty" tf:"service_instance,omitempty"`
}

type ServiceBindingParameters struct {

	// +kubebuilder:validation:Optional
	ParamsJSONSecretRef *v1.SecretKeySelector `json:"paramsJsonSecretRef,omitempty" tf:"-"`

	// A list of key/value parameters used by the service broker to create the binding. Defaults to empty map.
	// +kubebuilder:validation:Optional
	ParamsSecretRef *v1.SecretReference `json:"paramsSecretRef,omitempty" tf:"-"`

	// The service instance GUID.
	// +kubebuilder:validation:Optional
	ServiceInstance *string `json:"serviceInstance" tf:"service_instance,omitempty"`
}

// AppSpec defines the desired state of App
type AppSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AppParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider AppInitParameters `json:"initProvider,omitempty"`
}

// AppStatus defines the observed state of App.
type AppStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AppObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// App is the Schema for the Apps API. Provides a Cloud Foundry Application resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudfoundry}
type App struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.space) || (has(self.initProvider) && has(self.initProvider.space))",message="spec.forProvider.space is a required parameter"
	Spec   AppSpec   `json:"spec"`
	Status AppStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AppList contains a list of Apps
type AppList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []App `json:"items"`
}

// Repository type metadata.
var (
	App_Kind             = "App"
	App_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: App_Kind}.String()
	App_KindAPIVersion   = App_Kind + "." + CRDGroupVersion.String()
	App_GroupVersionKind = CRDGroupVersion.WithKind(App_Kind)
)

func init() {
	SchemeBuilder.Register(&App{}, &AppList{})
}
